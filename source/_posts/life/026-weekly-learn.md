---
title: 2019-32-周报
tags:
  - life
  - week
p: life/026-weekly-learn
date: 2019-08-05 20:09:29
---

这是2019年第32周周报.

事情变化的速度旺旺超出你的想象，今天还一切正常，明天就灰飞烟灭。
再回过头来看，当时觉得天都要塌下来的事情，现在觉得不痛不痒，居然一点也不惊奇。
我不否认人的基因具有遗忘痛苦的功能，因此卧薪尝胆、悬梁刺股的故事才能流传，一定要让自己记得当初有多痛苦，才能珍惜现在所得。
我一步一步地做到心平气和，好像到了不惑之年了。
我要再去接受更大的挑战，沉浸在忙碌的工作中，再次找回自我，重温当初的痛苦。为此，我拼尽最后的力气，争取到这种平台。
没错，一个让人挤破头想进的地方，也同样有那么多人想出来。围城不可怕，被困在围城里或者外面才可怕，要做到进得去处得来，
随时进、随时出，这是我所追求的人生目标。

1. 看面试题学习：范围为JVM、多线程、kafka、redis、spring

2. 参与面试：经过了5轮（技术1、技术2、产品经理、部门负责人、HR）

类加载机制：

- 加载(玩出了花样-jar，war，zip)
- 验证（安全，VerifyError，格式、元数据、字节码、符号引用（找不到方法或类）-Xverify:none）
- 准备: 设置初值
- 解析：符号引用替换为直接引用（类、接口、字段、方法），找不到依然报错
- 初始化：执行构造器、static块
- 使用
- 卸载

-XX:+TraceClassLoading

类加载器：

- 启动类
- 扩展类
- 应用程序类
- 自定义类加载器

双亲委派模型：优先父类加载器（组合形式）加载，找不到才子类，why？因为和jdk重名就混乱了

# mysql
[count(1) vs count(*) vs count(col)的区别](https://blog.csdn.net/iFuMI/article/details/77920767)

any, some, all,  exists(子查询)

不能同时查询和修改

mysql独有的操作符`<=>`: 

```m
mysql> SELECT 1 <=> 1, NULL <=> NULL, 1 <=> NULL;
        -> 1, 1, 0
mysql> SELECT 1 = 1, NULL = NULL, 1 = NULL;
        -> 1, NULL, NULL
```
## 使用B+树索引的技巧

记住：二级索引需要回表操作（先查到主键，再通过主键查询返回完整记录）

1. 不要用 `seelct *`, 制定列，最好只包含索引列
2. 只对搜索、排序、聚合的列建立索引
3. 列的值不能大量重复，否则索引没有意义
4. 索引列尽量小，占用空间小，查询越快；可以只指定对前缀编码：`KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)`


## 连接查询原理和优化

一般情况下，我们都把只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件都放到ON子句中，我们也一般把放到ON子句中的过滤条件也称之为连接条件。

1. 嵌套循环：最笨的方法，全表扫描

2. 

## 优化IN子查询的方式

```m
SELECT * FROM s1 
    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
```
1. 通过**物化表**(将子查询的结果集保存到临时表)
    1. 结果集小（tmp_table_size, max_heap_table_size）：建立基于内存的hash索引
    2. 结果集大：基于B+树的磁盘索引

2. 转成内连接优化： 选择哪个方向成本最低的来

3. 不通过物化直接转为内连接：mysql内部的半连接（semi join）操作

4. 如果都不行，会被转化为exists语句执行，充分利用索引











