---
title: geohash原理
tags:
  - geohash
p: basic/021-geohash
date: 2019-09-08 13:49:50
---

geohash原理。

# 经度和纬度

* 经度范围：【-180，180】
* 纬度范围：【-90，90】

# geohash运算过程

假设有一个经纬度为(116.389550，39.928176)的地点，我们对其纬度进行编码：
## 二分得到二进制代码

1. 对区间【-90，90】进行二分：（【-90，0），【0，90】），对应二进制为（0，1）确定39.928176属于右边，标记为1；
2. 对区间【0，90】进行二分：（【0，45），【45，90】），对应二进制为（0，1），确定39.928176属于左边，标记为0；
3. 递归上述过程使结果更精确，最后趋近于39.928176
4. 对经度执行同样的操作

这个过程可以表示如下图：

{% asset_img 000.jpg %}

## 合并经纬度二进制

我们将经纬度得到的15位二进制代码按奇偶交替形式合并：

1. 奇数位为纬度
2. 偶数位放经度

{% asset_img 001.jpg %}

## 按base32编码

base32编码也就是用32个字符来进行编码：2^5=32, 因此每5位二进制对应一个字符。

这32个字符为：`0-9` + `a-z`, 但除去4个字母：`a, i, l, o` ,我猜他们长得太像数字了吧。

1. 按上面得到的二进制序列每5位进行分组：`11100 11101 00100 01111 0000  01101`
2. 转为十进制：`28 29 4 15 0 13`
3. 于是得到base32编码为：`wx4g0e`

# geohash算法的特点和问题

## 特点

查看下图：按照二分法进行编码后，一个格子可以分为4份、8份、2^n份，每一份的4个小格子都像个Z字（下图向右旋转90度）

{% asset_img 002.jpg %}

旋转后如下图：可能这就是Z曲线的来源

{% asset_img 003.png %}

## 问题

很明显，这个跳跃性太大了，0111和1000本来编码是连着的，但空间位置却相差甚远。



